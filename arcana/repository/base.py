from builtins import object
from abc import ABCMeta, abstractmethod
from nipype.interfaces.base import (
    traits, DynamicTraitedSpec, Undefined, File, Directory,
    BaseInterface)
from arcana.node import Node
from arcana.dataset import (
    BaseDatum, DatasetSpec, FieldSpec, BaseField, BaseDataset,
    DatasetMatch, FieldMatch)
from arcana.exception import ArcanaError
from arcana.utils import PATH_SUFFIX, FIELD_SUFFIX
from future.utils import with_metaclass

PATH_TRAIT = traits.Either(File(exists=True), Directory(exists=True))
FIELD_TRAIT = traits.Either(traits.Int, traits.Float, traits.Str)
MULTIPLICITIES = ('per_session', 'per_subject', 'per_visit', 'per_project')


class Repository(with_metaclass(ABCMeta, object)):
    """
    Abstract base class for all Repository systems, DaRIS, XNAT and local file
    system. Sets out the interface that all Repository classes should implement.
    """

    @abstractmethod
    def source(self, inputs, name=None, study_name=None, **kwargs):
        """
        Returns a NiPype node that gets the input data from the repository
        system. The input spec of the node's interface should inherit from
        RepositorySourceInputSpec

        Parameters
        ----------
        project_id : str
            The ID of the project to return the sessions for
        inputs : list(Dataset|Field)
            An iterable of arcana.Dataset or arcana.Field
            objects, which specify the datasets to extract from the
            repository system
        name : str
            Name of the NiPype node
        study_name: str
            Prefix used to distinguish datasets generated by a particular
            study. Used for derived datasets only
        """
        if name is None:
            name = "{}_source".format(self.type)
        inputs = list(inputs)  # protected against iterators
        datasets = []
        fields = []
        for inpt in inputs:
            if isinstance(inpt, DatasetMatch):
                datasets.append(inpt.matches)
            elif isinstance(inpt, DatasetSpec):
                datasets.append(inpt)
            if isinstance(inpt, FieldMatch):
                fields.append(inpt.matches)
            elif isinstance(inpt, FieldSpec):
                fields.append(inpt)
        return Node(self.Source(study_name, datasets, fields, **kwargs),
                    name=name)

    @abstractmethod
    def sink(self, outputs, frequency='per_session', name=None,
             study_name=None, **kwargs):
        """
        Returns a NiPype node that puts the output data back to the repository
        system. The input spec of the node's interface should inherit from
        RepositorySinkInputSpec

        Parameters
        ----------
        project_id : str
            The ID of the project to return the sessions for
        outputs : List(BaseFile|Field) | list(
            An iterable of arcana.Dataset arcana.Field objects,
            which specify the datasets to put into the repository system
        name : str
            Name of the NiPype node
        study_name: str
            Prefix used to distinguish datasets generated by a particular
            study. Used for derived datasets only

        """
        if name is None:
            name = "{}_{}_sink".format(self.type, frequency)
        outputs = list(outputs)  # protected against iterators
        if frequency.startswith('per_session'):
            sink_class = self.Sink
        elif frequency.startswith('per_subject'):
            sink_class = self.SubjectSink
        elif frequency.startswith('per_visit'):
            sink_class = self.VisitSink
        elif frequency.startswith('per_project'):
            sink_class = self.ProjectSink
        else:
            raise ArcanaError(
                "Unrecognised frequency '{}' can be one of '{}'"
                .format(frequency,
                        "', '".join(BaseDatum.MULTIPLICITY_OPTIONS)))
        datasets = [o for o in outputs if isinstance(o, BaseDataset)]
        fields = [o for o in outputs if isinstance(o, BaseField)]
        return Node(sink_class(study_name, datasets, fields, **kwargs),
                    name=name)

    def __ne__(self, other):
        return not (self == other)


class BaseRepositoryNode(BaseInterface):
    """
    Parameters
    ----------
    infields : list of str
        Indicates the input fields to be dynamically created

    outfields: list of str
        Indicates output fields to be dynamically created

    See class examples for usage

    """

    def __init__(self, study_name, datasets, fields):
        super(BaseRepositoryNode, self).__init__()
        self._study_name = study_name
        self._datasets = datasets
        self._fields = fields

    def __eq__(self, other):
        try:
            return (self.study_name == other.study_name and
                    self.datasets == other.datasets and
                    self.fields == other.fields)
        except AttributeError:
            return False

    def __repr__(self):
        return "{}(study_name='{}', datasets={}, fields={})".format(
            type(self).__name__, self.study_name, self.datasets,
            self.fields)

    def __ne__(self, other):
        return not self == other

    def _run_interface(self, runtime, *args, **kwargs):  # @UnusedVariable
        return runtime

    @property
    def study_name(self):
        return self._study_name

    @property
    def datasets(self):
        return self._datasets

    @property
    def fields(self):
        return self._fields

    @classmethod
    def _add_trait(cls, spec, name, trait_type):
        spec.add_trait(name, trait_type)
        spec.trait_set(trait_change_notify=False, **{name: Undefined})
        # Access the trait (not sure why but this is done in add_traits
        # so I have also done it here
        getattr(spec, name)

    def prefix_study_name(self, name, is_spec=True):
        """Prepend study name if defined"""
        if is_spec:
            name = self.study_name + '_' + name
        return name


class RepositorySourceInputSpec(DynamicTraitedSpec):
    """
    Base class for repository source input specifications. Provides a common
    interface for 'run_pipeline' when using the repository source to extract
    primary and preprocessed datasets from the repository system
    """
    subject_id = traits.Str(mandatory=True, desc="The subject ID")
    visit_id = traits.Str(mandatory=True, usedefult=True,
                            desc="The visit or derived group ID")


class RepositorySource(BaseRepositoryNode):
    """
    Parameters
    ----------
    datasets: list
        List of all datasets to be extracted from the repository
    fields: list
        List of all the fields that are to be extracted from the repository
    study_name: str
        Prefix prepended onto derived dataset "names"
    """

    output_spec = DynamicTraitedSpec
    _always_run = True

    def _outputs(self):
        outputs = super(RepositorySource, self)._outputs()
        # Add output datasets
        for dataset in self.datasets:
            assert isinstance(dataset, BaseDataset)
            self._add_trait(outputs, dataset.name + PATH_SUFFIX,
                            PATH_TRAIT)
        # Add output fields
        for field in self.fields:
            assert isinstance(field, BaseField)
            self._add_trait(outputs, field.name + FIELD_SUFFIX,
                            field.dtype)
        return outputs


class BaseRepositorySinkSpec(DynamicTraitedSpec):
    pass


class RepositorySinkInputSpec(BaseRepositorySinkSpec):

    subject_id = traits.Str(mandatory=True, desc="The subject ID"),
    visit_id = traits.Str(mandatory=False,
                            desc="The session or derived group ID")


class RepositorySubjectSinkInputSpec(BaseRepositorySinkSpec):

    subject_id = traits.Str(mandatory=True, desc="The subject ID")


class RepositoryVisitSinkInputSpec(BaseRepositorySinkSpec):

    visit_id = traits.Str(mandatory=True, desc="The visit ID")


class RepositoryProjectSinkInputSpec(BaseRepositorySinkSpec):
    pass


class BaseRepositorySinkOutputSpec(DynamicTraitedSpec):

    out_files = traits.List(PATH_TRAIT, desc='Output datasets')

    out_fields = traits.List(
        traits.Tuple(traits.Str, FIELD_TRAIT), desc='Output fields')


class RepositorySinkOutputSpec(BaseRepositorySinkOutputSpec):

    subject_id = traits.Str(desc="The subject ID")
    visit_id = traits.Str(desc="The visit ID")


class RepositorySubjectSinkOutputSpec(BaseRepositorySinkOutputSpec):

    subject_id = traits.Str(desc="The subject ID")


class RepositoryVisitSinkOutputSpec(BaseRepositorySinkOutputSpec):

    visit_id = traits.Str(desc="The visit ID")


class RepositoryProjectSinkOutputSpec(BaseRepositorySinkOutputSpec):

    project_id = traits.Str(desc="The project ID")


class BaseRepositorySink(BaseRepositoryNode):

    def __init__(self, study_name, datasets, fields):
        super(BaseRepositorySink, self).__init__(study_name, datasets,
                                              fields)
        # Add input datasets
        for dataset in datasets:
            assert isinstance(dataset, DatasetSpec)
            self._add_trait(self.inputs, dataset.name + PATH_SUFFIX,
                            PATH_TRAIT)
        # Add input fields
        for field in fields:
            assert isinstance(field, FieldSpec)
            self._add_trait(self.inputs, field.name + FIELD_SUFFIX,
                            field.dtype)


class RepositorySink(BaseRepositorySink):

    input_spec = RepositorySinkInputSpec
    output_spec = RepositorySinkOutputSpec

    frequency = 'per_session'

    def _base_outputs(self):
        outputs = self.output_spec().get()
        outputs['subject_id'] = self.inputs.subject_id
        outputs['visit_id'] = self.inputs.visit_id
        return outputs


class RepositorySubjectSink(BaseRepositorySink):

    input_spec = RepositorySubjectSinkInputSpec
    output_spec = RepositorySubjectSinkOutputSpec

    frequency = 'per_subject'

    def _base_outputs(self):
        outputs = self.output_spec().get()
        outputs['subject_id'] = self.inputs.subject_id
        return outputs


class RepositoryVisitSink(BaseRepositorySink):

    input_spec = RepositoryVisitSinkInputSpec
    output_spec = RepositoryVisitSinkOutputSpec

    frequency = 'per_visit'

    def _base_outputs(self):
        outputs = self.output_spec().get()
        outputs['visit_id'] = self.inputs.visit_id
        return outputs


class RepositoryProjectSink(BaseRepositorySink):

    input_spec = RepositoryProjectSinkInputSpec
    output_spec = RepositoryProjectSinkOutputSpec

    frequency = 'per_project'

    def _base_outputs(self):
        outputs = self.output_spec().get()
        return outputs
